//! CalDAV Calendar adapter - Implements CalendarPort using integration_caldav

use application::ports::{CalendarError, CalendarEvent, CalendarInfo, CalendarPort, NewEvent};
use async_trait::async_trait;
use chrono::{DateTime, NaiveDate, Utc};
use integration_caldav::{
    CalDavClient, CalDavConfig, CalDavError, CalendarEvent as CalDavEvent, HttpCalDavClient,
};
use tracing::{debug, instrument, warn};

use super::{CircuitBreaker, CircuitBreakerConfig};

/// Adapter for CalDAV calendar servers
pub struct CalDavCalendarAdapter {
    client: HttpCalDavClient,
    default_calendar: Option<String>,
    circuit_breaker: Option<CircuitBreaker>,
}

impl std::fmt::Debug for CalDavCalendarAdapter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CalDavCalendarAdapter")
            .field("client", &self.client)
            .field("default_calendar", &self.default_calendar)
            .field("circuit_breaker", &self.circuit_breaker.as_ref().map(|cb| cb.name()))
            .finish()
    }
}

impl CalDavCalendarAdapter {
    /// Create a new adapter with the given configuration
    pub fn new(config: CalDavConfig) -> Result<Self, CalendarError> {
        let default_calendar = config.calendar_path.clone();
        let client = HttpCalDavClient::new(config).map_err(Self::map_error)?;
        Ok(Self {
            client,
            default_calendar,
            circuit_breaker: None,
        })
    }

    /// Create with specific server settings
    pub fn with_server(
        server_url: &str,
        username: &str,
        password: &str,
        calendar_path: Option<&str>,
    ) -> Result<Self, CalendarError> {
        let config = CalDavConfig {
            server_url: server_url.to_string(),
            username: username.to_string(),
            password: password.to_string(),
            calendar_path: calendar_path.map(ToString::to_string),
            verify_certs: true,
            timeout_secs: 30,
        };
        Self::new(config)
    }

    /// Enable circuit breaker with default configuration
    #[must_use]
    pub fn with_circuit_breaker(mut self) -> Self {
        self.circuit_breaker = Some(CircuitBreaker::new("caldav-calendar"));
        self
    }

    /// Enable circuit breaker with custom configuration
    #[must_use]
    pub fn with_circuit_breaker_config(mut self, config: CircuitBreakerConfig) -> Self {
        self.circuit_breaker = Some(CircuitBreaker::with_config("caldav-calendar", config));
        self
    }

    /// Check if circuit breaker is blocking requests
    fn is_circuit_open(&self) -> bool {
        self.circuit_breaker
            .as_ref()
            .is_some_and(CircuitBreaker::is_open)
    }

    /// Get circuit breaker state description for logging
    fn circuit_state_desc(&self) -> &'static str {
        match &self.circuit_breaker {
            Some(cb) if cb.is_open() => "open",
            Some(cb) if cb.is_closed() => "closed",
            Some(_) => "half-open",
            None => "disabled",
        }
    }

    /// Check circuit and return error if open
    fn check_circuit(&self) -> Result<(), CalendarError> {
        if self.is_circuit_open() {
            warn!("CalDAV calendar circuit breaker is open, failing fast");
            return Err(CalendarError::ServiceUnavailable);
        }
        Ok(())
    }

    /// Map CalDavError to CalendarError
    fn map_error(e: CalDavError) -> CalendarError {
        match e {
            CalDavError::AuthenticationFailed => CalendarError::AuthenticationFailed,
            CalDavError::ConnectionFailed(_) => CalendarError::ServiceUnavailable,
            CalDavError::CalendarNotFound(name) => CalendarError::CalendarNotFound(name),
            CalDavError::EventNotFound(id) => CalendarError::EventNotFound(id),
            CalDavError::ParseError(msg) => CalendarError::InvalidDateTime(msg),
            CalDavError::RequestFailed(msg) => CalendarError::OperationFailed(msg),
        }
    }

    /// Convert CalDavEvent to port CalendarEvent
    fn convert_event(event: &CalDavEvent) -> CalendarEvent {
        CalendarEvent {
            id: event.id.clone(),
            title: event.summary.clone(),
            description: event.description.clone(),
            start: event.start.clone(),
            end: event.end.clone(),
            location: event.location.clone(),
            all_day: is_all_day(&event.start),
            attendees: event.attendees.clone(),
        }
    }

    /// Convert NewEvent to CalDavEvent
    fn convert_new_event(event: &NewEvent) -> CalDavEvent {
        CalDavEvent {
            id: String::new(), // Will be generated by server
            summary: event.title.clone(),
            description: event.description.clone(),
            start: event.start.clone(),
            end: event.end.clone(),
            location: event.location.clone(),
            attendees: event.attendees.clone(),
        }
    }

    /// Get default calendar or first available
    async fn get_default_calendar(&self) -> Result<String, CalendarError> {
        if let Some(ref cal) = self.default_calendar {
            return Ok(cal.clone());
        }

        let calendars = self
            .client
            .list_calendars()
            .await
            .map_err(Self::map_error)?;

        calendars
            .first()
            .cloned()
            .ok_or_else(|| CalendarError::CalendarNotFound("No calendars available".to_string()))
    }
}

/// Check if a datetime string represents an all-day event
fn is_all_day(datetime: &str) -> bool {
    // All-day events typically have date-only format (YYYY-MM-DD)
    // rather than full datetime
    !datetime.contains('T')
}

/// Format a date for CalDAV
fn format_date_for_caldav(date: NaiveDate) -> (String, String) {
    let start = format!("{}T00:00:00", date);
    let end = format!("{}T23:59:59", date);
    (start, end)
}

#[async_trait]
impl CalendarPort for CalDavCalendarAdapter {
    #[instrument(skip(self), fields(circuit = %self.circuit_state_desc()))]
    async fn list_calendars(&self) -> Result<Vec<CalendarInfo>, CalendarError> {
        self.check_circuit()?;
        debug!("Listing calendars from CalDAV");

        let calendars = self
            .client
            .list_calendars()
            .await
            .map_err(Self::map_error)?;

        Ok(calendars
            .into_iter()
            .enumerate()
            .map(|(i, name)| CalendarInfo {
                id: name.clone(),
                name,
                color: None,
                is_default: i == 0,
            })
            .collect())
    }

    #[instrument(skip(self), fields(circuit = %self.circuit_state_desc()))]
    async fn get_events_for_date(
        &self,
        date: NaiveDate,
    ) -> Result<Vec<CalendarEvent>, CalendarError> {
        self.check_circuit()?;
        debug!(date = %date, "Getting events for date from CalDAV");

        let calendar = self.get_default_calendar().await?;
        let (start, end) = format_date_for_caldav(date);

        let events = self
            .client
            .get_events(&calendar, &start, &end)
            .await
            .map_err(Self::map_error)?;

        Ok(events.iter().map(Self::convert_event).collect())
    }

    #[instrument(skip(self), fields(circuit = %self.circuit_state_desc()))]
    async fn get_events_in_range(
        &self,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> Result<Vec<CalendarEvent>, CalendarError> {
        self.check_circuit()?;
        debug!(start = %start, end = %end, "Getting events in range from CalDAV");

        let calendar = self.get_default_calendar().await?;
        let start_str = start.to_rfc3339();
        let end_str = end.to_rfc3339();

        let events = self
            .client
            .get_events(&calendar, &start_str, &end_str)
            .await
            .map_err(Self::map_error)?;

        Ok(events.iter().map(Self::convert_event).collect())
    }

    #[instrument(skip(self), fields(circuit = %self.circuit_state_desc()))]
    async fn get_event(&self, event_id: &str) -> Result<CalendarEvent, CalendarError> {
        self.check_circuit()?;
        debug!(event_id, "Getting event from CalDAV");

        // CalDAV doesn't have a direct get-by-ID, so we search recent events
        let calendar = self.get_default_calendar().await?;
        let now = Utc::now();
        let start = (now - chrono::Duration::days(365)).to_rfc3339();
        let end = (now + chrono::Duration::days(365)).to_rfc3339();

        let events = self
            .client
            .get_events(&calendar, &start, &end)
            .await
            .map_err(Self::map_error)?;

        events
            .iter()
            .find(|e| e.id == event_id)
            .map(Self::convert_event)
            .ok_or_else(|| CalendarError::EventNotFound(event_id.to_string()))
    }

    #[instrument(skip(self, event), fields(circuit = %self.circuit_state_desc()))]
    async fn create_event(&self, event: &NewEvent) -> Result<String, CalendarError> {
        self.check_circuit()?;
        debug!(title = %event.title, "Creating event in CalDAV");

        let calendar = self.get_default_calendar().await?;
        let caldav_event = Self::convert_new_event(event);

        self.client
            .create_event(&calendar, &caldav_event)
            .await
            .map_err(Self::map_error)
    }

    #[instrument(skip(self, event), fields(circuit = %self.circuit_state_desc()))]
    async fn update_event(&self, event_id: &str, event: &NewEvent) -> Result<(), CalendarError> {
        self.check_circuit()?;
        debug!(event_id, title = %event.title, "Updating event in CalDAV");

        let calendar = self.get_default_calendar().await?;
        let mut caldav_event = Self::convert_new_event(event);
        caldav_event.id = event_id.to_string();

        self.client
            .update_event(&calendar, &caldav_event)
            .await
            .map_err(Self::map_error)
    }

    #[instrument(skip(self), fields(circuit = %self.circuit_state_desc()))]
    async fn delete_event(&self, event_id: &str) -> Result<(), CalendarError> {
        self.check_circuit()?;
        debug!(event_id, "Deleting event from CalDAV");

        let calendar = self.get_default_calendar().await?;

        self.client
            .delete_event(&calendar, event_id)
            .await
            .map_err(Self::map_error)
    }

    async fn is_available(&self) -> bool {
        // If circuit is open, report as unavailable
        if self.is_circuit_open() {
            debug!("CalDAV calendar unavailable: circuit breaker open");
            return false;
        }
        // Try to list calendars as a health check
        self.client.list_calendars().await.is_ok()
    }

    #[instrument(skip(self), fields(circuit = %self.circuit_state_desc()))]
    async fn get_next_event(&self) -> Result<Option<CalendarEvent>, CalendarError> {
        self.check_circuit()?;
        debug!("Getting next event from CalDAV");

        let calendar = self.get_default_calendar().await?;
        let now = Utc::now();
        let end = now + chrono::Duration::days(7); // Look a week ahead

        let events = self
            .client
            .get_events(&calendar, &now.to_rfc3339(), &end.to_rfc3339())
            .await
            .map_err(Self::map_error)?;

        // Find the next event by start time
        let mut sorted: Vec<_> = events.iter().collect();
        sorted.sort_by(|a, b| a.start.cmp(&b.start));

        Ok(sorted.first().map(|e| Self::convert_event(e)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_config() -> CalDavConfig {
        CalDavConfig {
            server_url: "https://cal.example.com".to_string(),
            username: "user".to_string(),
            password: "password".to_string(),
            calendar_path: Some("/calendars/default".to_string()),
            verify_certs: true,
            timeout_secs: 30,
        }
    }

    #[test]
    fn adapter_creation() {
        let adapter = CalDavCalendarAdapter::new(test_config());
        assert!(format!("{adapter:?}").contains("CalDavCalendarAdapter"));
    }

    #[test]
    fn adapter_with_server() {
        let adapter = CalDavCalendarAdapter::with_server(
            "https://cal.example.com",
            "user",
            "password",
            Some("/calendars/default"),
        );
        assert!(format!("{adapter:?}").contains("CalDavCalendarAdapter"));
    }

    #[test]
    fn map_error_auth_failed() {
        let err = CalDavCalendarAdapter::map_error(CalDavError::AuthenticationFailed);
        assert!(matches!(err, CalendarError::AuthenticationFailed));
    }

    #[test]
    fn map_error_connection_failed() {
        let err =
            CalDavCalendarAdapter::map_error(CalDavError::ConnectionFailed("test".to_string()));
        assert!(matches!(err, CalendarError::ServiceUnavailable));
    }

    #[test]
    fn map_error_calendar_not_found() {
        let err =
            CalDavCalendarAdapter::map_error(CalDavError::CalendarNotFound("cal".to_string()));
        assert!(matches!(err, CalendarError::CalendarNotFound(_)));
    }

    #[test]
    fn map_error_event_not_found() {
        let err = CalDavCalendarAdapter::map_error(CalDavError::EventNotFound("evt".to_string()));
        assert!(matches!(err, CalendarError::EventNotFound(_)));
    }

    #[test]
    fn map_error_parse_error() {
        let err = CalDavCalendarAdapter::map_error(CalDavError::ParseError("bad date".to_string()));
        assert!(matches!(err, CalendarError::InvalidDateTime(_)));
    }

    #[test]
    fn map_error_request_failed() {
        let err = CalDavCalendarAdapter::map_error(CalDavError::RequestFailed("error".to_string()));
        assert!(matches!(err, CalendarError::OperationFailed(_)));
    }

    #[test]
    fn convert_event() {
        let caldav_event = CalDavEvent {
            id: "evt-1".to_string(),
            summary: "Meeting".to_string(),
            description: Some("Weekly sync".to_string()),
            start: "2024-01-15T10:00:00Z".to_string(),
            end: "2024-01-15T11:00:00Z".to_string(),
            location: Some("Room A".to_string()),
            attendees: vec!["alice@example.com".to_string()],
        };

        let event = CalDavCalendarAdapter::convert_event(&caldav_event);

        assert_eq!(event.id, "evt-1");
        assert_eq!(event.title, "Meeting");
        assert_eq!(event.description, Some("Weekly sync".to_string()));
        assert!(!event.all_day);
    }

    #[test]
    fn convert_all_day_event() {
        let caldav_event = CalDavEvent {
            id: "evt-2".to_string(),
            summary: "Holiday".to_string(),
            description: None,
            start: "2024-01-15".to_string(),
            end: "2024-01-15".to_string(),
            location: None,
            attendees: vec![],
        };

        let event = CalDavCalendarAdapter::convert_event(&caldav_event);

        assert!(event.all_day);
    }

    #[test]
    fn convert_new_event() {
        let new_event = NewEvent::new("Meeting", "2024-01-15T10:00:00Z", "2024-01-15T11:00:00Z")
            .with_description("Description")
            .with_location("Room A");

        let caldav_event = CalDavCalendarAdapter::convert_new_event(&new_event);

        assert!(caldav_event.id.is_empty()); // ID generated by server
        assert_eq!(caldav_event.summary, "Meeting");
        assert_eq!(caldav_event.description, Some("Description".to_string()));
        assert_eq!(caldav_event.location, Some("Room A".to_string()));
    }

    #[test]
    fn is_all_day_true() {
        assert!(is_all_day("2024-01-15"));
    }

    #[test]
    fn is_all_day_false() {
        assert!(!is_all_day("2024-01-15T10:00:00Z"));
    }

    #[test]
    fn format_date_for_caldav_correct() {
        let date = NaiveDate::from_ymd_opt(2024, 1, 15).unwrap();
        let (start, end) = format_date_for_caldav(date);

        assert_eq!(start, "2024-01-15T00:00:00");
        assert_eq!(end, "2024-01-15T23:59:59");
    }
}
